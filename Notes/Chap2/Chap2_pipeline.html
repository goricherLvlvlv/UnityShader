<!DOCTYPE html>
<html>
<head>
<title>Chap2_pipeline.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h2 id="%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF"><em><strong>渲染流水线</strong></em></h2>
<hr>
<h4 id="learnopengl-cn"><strong>LearnOpenGL-CN</strong></h4>
<p>最早对pipeline的认识来自于learn-opengl网址上的介绍. 如下图所示.
<img src="pipeline.png" alt=""></p>
<ul>
<li>
<p>将物体的顶点作为输入, 从一个3D坐标转为另一个3D坐标. 这也就是顶点着色器的作用.</p>
</li>
<li>
<p>下一步则是进行图元装配(primitive assembly). 图元是什么? 这个问题困扰过我很久, 而后在查阅了各类资料并与该网址对比后得知, 图元就是渲染的基础单位, 点、线、三角形、正方形...(但实际上图元只有三角形一种, 点线正方形都是由三角形变性组合而生成的).</p>
<blockquote>
<p>为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)</p>
</blockquote>
</li>
<li>
<p>我从没有了解过几何着色器, 写这篇笔记时我查阅了一些资料, 有一张图是我认为可以帮助理解, 如下所示. 几何着色器作为vertex shader与pixel shader的中间层存在着. 在dx10中第一次出现几何着色器的使用, 它主要的功能是以部分顶点信息来批量处理几何图形, 对vertex旁边的数据快速处理, 创造出新的多边形.</p>
<p>在learnopengl了解到, 几何着色器将输入的几个顶点, 绘制成一个以上简单的图元, 通常是以三角形的形式来存在的. 最常见的还是使用在爆炸效果中, 可以知道常见的爆炸并不是破坏物体的面片, 而是让其沿法线方向进行一定的运动. 无论物体有多复杂, 我们都可以通过三角形的3个顶点来实现, 两条线段进行叉乘即可获得法线, 从而完成爆炸计算.</p>
<p><img src="shaders.png" alt=""></p>
</li>
<li>
<p>下一个阶段则是被称为光栅化阶段. 将primitive映射成屏幕上的像素点, 之后会对图形进行裁切, 剪除视野内看不到的像素点, 提高效率减少fragment shader浪费计算. 之后通过fragment shader完成上色方面的计算, 最后经过test与blend形成最后的颜色.</p>
</li>
</ul>
<hr>
<h4 id="unity-shader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81"><strong>Unity Shader 入门精要</strong></h4>
<p>本书上对渲染管线的理解来源于real-time rendering这本渲染天书中. 书中对渲染管线分成了三个阶段, 应用阶段、几何阶段与光栅化阶段.</p>
<p><img src="pipeline2.png" alt=""></p>
<ul>
<li>应用阶段属于纯开发者控制的阶段, 即我们在unity中搭建物体, 撰写脚本. 同时在这个阶段我们可以完成occulusion culling以及lightmap方面的优化, 提高渲染的性能. 然后将顶点颜色信息输入给几何阶段则是该阶段要做的最重要的事情.</li>
<li>几何阶段则是将每一个渲染用的primitives从model space转换到屏幕空间中, 再交付给光栅化阶段.</li>
<li>光栅化阶段与前面learn-opengl中的差别不大, 不展开描述了.</li>
</ul>
<h4 id="gpu%E6%B5%81%E6%B0%B4%E7%BA%BF"><strong>GPU流水线</strong></h4>
<p><img src="GPU流水线.png" alt=""></p>
<blockquote>
<p>颜色表示了不同阶段的可配置性或可编程性：绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是由GPU固定实现的，开发者没有任何控制权。实线表示该shader必须由开发者编程实现，虚线表示该Shader是可选的</p>
</blockquote>
<ul>
<li>顶点着色器: 空间变换. 由model space =&gt; NDC space.</li>
<li>曲面细分着色器: 由GPU来进行平面的细分, 生成曲面, 而细分的规则由开发者指定.</li>
<li>几何着色器: 批量处理几何图形.</li>
<li>裁剪: 剔除不在摄像机frustrator中的面片.</li>
<li>屏幕映射: 将图元的坐标转到屏幕坐标系中.</li>
<li>三角形设置: 光栅化的初始阶段. 这个阶段计算光栅化一个三角网格所需要的信息. 将上一阶段获得的顶点坐标进行计算, 获得每一条边的像素坐标.</li>
<li>三角形遍历: 检查每一个像素点是否被某个三角网格覆盖, 如果被覆盖则生成一个片元. 并通过插值计算每一个像素点的深度(当然还有法线, 切线等等信息).</li>
<li>片元着色器: 逐片元的着色方式. 获得前一步计算出的每一个片元的信息, 把三个顶点的texcoord坐标进行插值, 获取覆盖到的片元的texcoord坐标(再经过缩放和平移获得uv坐标), 进行纹理采样获得纹理颜色.</li>
<li>逐片元操作: 修改颜色、深度缓冲、混合等操作. 通过一系列的测试工作决定每一个片元的可见性, 在通过所有测试后, 将该片元的颜色(SrcColor)与颜色缓冲区的颜色(DstColor)进行混合. 模版测试的作用主要用于渲染阴影或者轮廓等, 而深度测试是让物体的显示更符合显示, 靠近眼睛的物体往往可以挡住较远的物体.</li>
<li>Early-Z: 在深度测试之前流水线已经经过了颜色计算等操作, 而无法通过深度测试的片元计算的颜色往往是在白白耗费性能, 于是有了Early-Z的技术, 如字面意思它可以在片元着色器之前就执行深度测试, 从而提前抛弃无法被看见的片元, 减少计算量提高性能. 当然这也会带来一些冲突, 如使用透明的片元则会出现问题, 当透明的片元深度值较低时(靠近人眼), 而后的高深度值的片元会被抛弃, 这与我们想要的结果不符(我们期望透明片元的颜色能与非透明片元的颜色进行Blend).</li>
<li>双重缓冲: 为了让每一帧的图片看起来更加有连续性, 我们使用了双重缓冲的策略, 逐片元操作发生在Back Buffer渲染完所有片元后交付给Front Buffer, 一次性将一整张图显示在用户面前.</li>
</ul>
<h4 id="cpu%E4%B8%8Egpu%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><strong>CPU与GPU的通信方式</strong></h4>
<p>pipeline的起点是cpu, 以下则是cpu行为的三个阶段:</p>
<ol>
<li>把数据加载到显存当中. 将渲染所需要的数据从硬盘加载到系统内存(Random Access Memory)中. 之后再讲grid和texture等等(例如normal, tangent)加载至显存当中, 这是因为显卡在VRAM(Video Random Access Memory)有着更高的读写速度, 而且大多数显卡不具有访问RAM的权限.</li>
<li>设置渲染的状态. 让CPU来指定需要的纹理、材质以及着色器, 这就是设置渲染状态的过程, 准备好以上的状态后, CPU会发起一个Draw Call给GPU.</li>
<li>调用Draw Call. 一个Draw Call仅仅会指向一个primitives.</li>
</ol>
<h4 id="%E5%85%B3%E4%BA%8Edraw-call"><strong>关于Draw Call</strong></h4>
<ol>
<li>CPU与GPU是怎么实现并行工作的?
<blockquote>
<p>在CPU与GPU之间使用一个命令缓冲区(Command Buffer). CPU往Command Buffer的队列中添加命令, 而GPU每完成一个渲染任务后则从中读取命令, 并去执行.</p>
</blockquote>
</li>
<li>为什么Draw Call较多会影响帧数?
<blockquote>
<p>因为每一次Draw Call前要进行许多零碎的工作, 当次数多了之后, 这些零碎的工作则会消耗CPU大量的性能去执行. 导致CPU过载, 从而帧数降低.</p>
</blockquote>
</li>
<li>如何减少Draw Call?
<blockquote>
<p>使用批处理(Batching)的方式来降低Draw Call(只是其中一种方式). 通过把多个网格合并成一个网格保存在内存中, 来降低DC, 而合并网格也需要消耗时间, 所以这个方法适用于静态物体, 对于动态物体的批处理可能还会得不偿失. 像上述的一个大的网格只消耗一次DC. 要注意的是, 一个网格内的物体只能使用同一种渲染状态, 如果之间会使用不同的渲染状态则无法使用批处理.</p>
</blockquote>
</li>
</ol>

</body>
</html>
